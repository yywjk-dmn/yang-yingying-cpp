基于函数编程

面向对象编程:
1.访问对属性关闭，对方法开放
2.指针成员在构造函数中申请  在析构函数中释放
3.类中有指针成员 要写拷贝构造和赋值运算符重载的深度拷贝
4.类对扩展开放（可以进行扩展） 对修改关闭（不要轻易的修改）

编译器默认生成的函数：
1.无参函数
2.拷贝函数
3.赋值运算符的重载函数

1.class 类关键字
    struct 和 class 的区别：
    默认的访问权限不一样
    class : 默认私有
    struct : 默认公有

private : 私有，只能在类内使用
public : 共有，类内和类外都可以进行使用
在类内声明一个函数 要在函数前面加入出处

2.构造函数和析构函数(用来管理堆上的空间)

构造函数：用于初始化对象状态的函数(内存申请的时候调用构造函数)
特点：1.不需要手动调用
    2.当不定义构造函数时 编译器会自动创建一个默认的构造函数
    3.构造函数的函数名和类名相同 无返回值
    4.所有的类 在调用的时候一定会创建一个构造函数 当自定义了构造函数 编译器就不会自动生成构造函数
    5.构造函数可以重载
    
    拷贝构造函数(复制构造函数)：
    1.函数形式：构造函数的函数名和类名相同 无返回值 为避免一直拷贝 参数只能是类的引用
    ⭐2.浅拷贝：当类中含有指针属性时 如果调用拷贝构造 拷贝的是指针的值 使得两个对象的指针指向同一块内存  析构函数释放时发生二次释放
    深度拷贝：内存复制 复制内存 而不是指针本身

    赋值运算符的重载函数：

析构函数：用来释放对象的状态
特点：1.不需要手动调用 系统会自动调用析构函数  C++中所有的对象都会调用析构函数(内存释放的时候才会调用析构)
    2.函数形式：函数名和类名相同 在名称前面加一个'~' 
    3.析构函数没有参数
    4.析构函数不能重载

RVO优化：return value optimiser  返回值优化 
将亡值：可以看作是一个右值

⭐new&delete 和 malloc&free 的区别
1.malloc&free 是函数   new&delete 是关键字
2.new不需要计算申请的空间大小  不需要指针转化  不需要判断指针是否为空（会抛出异常 终止程序）
3.new&delete 会调用构造函数和析构函数   malloc&free不会

匿名对象：生命周期只有一行代码

（关键字·）explicit:防止隐式转换

（关键字）const:
初始化列表：简化构造函数
1.常成员变量必须在初始化列表中进行初始化
2.普通成员变量也可以在初始化列表中初始化
3.初始化列表的操作快于构造函数的主体
const 对成员变量的修饰：
1.const int * func   //保护返回值
2.void func2(const int &a)  //保护引用参数
3.void func3() const  //保护是整个参数 不允许对成员参数做修改

(关键字)static:
C语言：1.局部变量：延长生命周期 只初始化一次
    2.全局变量：只作用于当前文件  extern(声明外部函数或者变量)

C++：1.修饰成员变量 该变量不属于某一个类的成员 而属于类 由该类的所有成员共享
    2.修饰成员函数：该函数不属于成员 而是由所有成员共享（成员函数依赖于对象）静态成员函数不能访问普通类的成员变量 只能访问静态成员变量
注意事项：1.初始化不由类的对象完成 而由类自己完成（内存由类本身分配）

所有的关键字都在声明的时候定义 在函数定义的时候不能加关键字

单例模式：全局该类只有一个对象的设计模式
1.防止对象在外部创建（也就是防止构造函数在外部调用）： 构造函数的私有化
2.构建一个静态接口 给外部使用
3.在静态接口中构建static变量，返回该变量的指针

this指针：指向本类对象
1.*this获取本对象
2.可以用this类区分类成员和形参
3.静态函数（不依赖对象 没有内存 没有地址）不能使用this指针（静态函数和对象不挂钩）

friend:友元关键字  被friend修饰的函数 叫做友元函数
友元函数：访问类的私有成员
友元类：该类可以访问类的所有私有成员
友元关系不可以进行传递 是单向的
