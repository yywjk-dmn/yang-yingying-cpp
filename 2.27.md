c++相较于C语言的加强

#include <cstring>  和  #include <string>  
前者代表包含C语言标准库中的函数 后者则是C++标准库的头文件

1.名称控制：
    1、'::'  域解析符  C++的标准输出语句：“std::cout<<a<<std::endl;
    2、namespace 命名空间：命名空间可以存放函数，也可以存放变量
    using namespace std;  代表全局使用std的命名空间 但是会出现函数的歧义问题 例如bind函数
    注：使用命名空间 用这种表达方式范围越小越好 不会出现歧义问题
    使用命名空间的表达方式：   std::cout<<A::num<<std::endl  或  using namespase A
    3、using 声明后面的符号可用
    4、std:C标准的命名空间


2.更严格的类型控制
    最小的字节是bite
    1.bool类型:判断真假 true为1 false为0 非0值都是1
      bool类型的大小是一个字节
    2.enum: 在C语言中 默认情况下枚举常量是整数类型 从0开始递增 两个枚举之间可以进行比较 因为本质上就是值的比较
            在C++中 两个枚举之间不能进行比较 因为在C++中 不同的两个枚举被视为两个不同的类型

3.运算符的加强
    三目运算符的加强  a > b ? b : a 
    C语言 返回的是值而不是变量本身
    C++ 返回的是地址空间也就是变量本身

4.关键字加强
    指针常量：指针是一个常量 int * const p = &a
    常量指针：指针指向一个常量 int const int *p = &a

    数组指针：本质是一个指针 返回值是数组
    指针数组：本质是一个数组 有一个指针指向该数组

    指针函数：本质是一个函数 有一个指针指向该函数
    函数指针：本质是一个指针 返回值是一个函数

    1、const:
        c++中不可以通过指针修改 (即使地址改变了 但是由于有关键字限制 显示还是原来的值 并且会将该常量放在符号表中 每次去该值 都会取到符号表里面的值 --- 真常量)

        define 和 const ：
        1.由于C++中命名空间对define无约束力 define定义的变量可以全局使用 所以推荐使用const来约束 以达到c语言中define的效果 (常量效果)
        2.在C++中 define不能定义类型 默认是int类型 而const可以自己定义变量的类型

5.struct加强
    结构体本身的名字就作为类型 不需要typedef重命名
    内部可以定义函数
    可以用using来代替typedef来重命名一个结构体的名字：
    using TcpS = stdTcpStudent;

6.指针加强
    1、变量名:
    2、指针:内存的地址空间
    3、引用:内存的别名  （相当于是变量的小名 指的就是所指向的变量）
        本质：指针常量 int &b = a   ==  int *const b = &a; (编译阶段会改变)
        注意事项：①要再定义时进行初始化 
                ②初始化以后不再改变朝向 
                ③本质是指针常量，编译期替换 
                ④引用的大小就是原变量的大小

7.左值和右值
    左值：有内存空间的值 可以进行改变的值
    右值：没有内存的值 常量
    const int &a:常量引用 解决右值没有办法传递给左值引用的问题 减少内存拷贝

8.函数加强
    1、内联函数 
    内联规则：①不要有循环 
             ②不能有太多的条件分支 
             ③不能取函数地址 
             ④不能有递归
    2、默认参数
        ①函数声明的时候添加默认参数
        ②默认参数必须放在参数列表的末尾
        ③默认参数的后面全部都是默认参数
    3、函数重载(多态) ：函数名相同,函数的定义不一样
        ①参数类型不一样
        ②参数数量不一样   默认参数不可以重载（参数数量不确定）占位参数可以进行重载（参数数量确定）
        ③参数顺序不一样

9.c和c++联合编译
    extern "C" :以C语言的函数命名方式进行编译 (用extern "C" 包含所有函数接口)
    #define
    #ifdef __cplusplus  （判断是否是在C++语境 是C++语境就走到  extern "C"）
    extern "C"
    {
    #endif
        函数：add();
    #ifdef __cplusplus
    } 
    #endif

10.c++内存管理
    c语言的内存管理(堆空间):malloc(申请内存) free(释放空间) 
    c++:   new（申请内存）：等同于malloc
       1.不需要计算内存的大小
       2.不需要用指针进行转换
       3.不需要判断指针是否为空：只要抛出异常，就会终止程序
           delete 释放堆内存空间 
        new[] delete []s; 释放数组
        new() delete s; 释放s值 简单数据类型时可以直接使用这个delete s
