1.类的成员变量不占用类的内存大小

2.struct：默认属性是公有,加上private是私有

3.继承：
非虚继承：
    父类（超类）成员在子类（派生类）成员的前面
以下两种都拿不到属性：
    1.公有继承 但是是私有方法
    2.公有属性的私有继承
继承拿到的东西按照最小的权限来定
权限大小排序：
    public>protect>private

4.初始化列表：
    1.初始化列表只能用在构造函数中
    2.初始化顺序只和成员变量的声明顺序有关
    3.是一种初始化成员变量的方式


5.构造函数的相互调用
    Student():Student(0,0){}  这是一种初始化的方式 先进行有参构造 在进行无参构造 将成员变量都初始化为0
    下面是一种错误的表示手法：
    Student()
    {
        Student(0,0);
    }

6.父类的构造函数
    1.子类的构造函数会默认调用父类的无参构造函数
    2.如果子类已经调用了父类的有参构造函数 就不会再调用父类的无参构造
    3.如果父类缺少无参构造 那么子类必须显式调用父类的有参构造函数

7.子类指针不允许指向父类对象 父类指针允许指向子类对象
    Person * per = new Student (允许)

8.静态成员变量一定要在类外初始化
    static修饰的变量（属性）：是属于类的（全局的） 访问方式有3种
    static修饰的函数（方法）：拿不到所有能用this拿到的变量和方法

9.多态
    1.子类重写父类的成员函数
    2.父类指针指向子类对象
    3.利用父类指针调用重写的成员函数

10.虚函数
    1.C++中的多态通过虚函数来进行实现
    2.虚函数通过virtual关键字来进行修饰
    3.要是在父类里面对虚函数加了virtual进行修饰 那子类中重写的函数就自动变为虚函数

11.虚表（虚函数表）
    虚函数的实现原理 虚表中存储着最终需要调用的虚函数地址

12.调用父类的函数实现
    Person::makeMoney();

13.虚析构函数
    1.如果存在父类指针指向子类的情况 应该将析构函数声明为虚函数（虚析构函数）

14.纯虚函数
    没有函数体且初始化为0的虚函数

15.多继承
    C++允许一个类可以有多个父类 但是不建议使用 

16.多继承函数下的构造函数

16.同名函数

17.同名变量

菱形继承问题：浪费内存空间，冗余 重复 解决问题方法:虚继承 